#include <chrono>
#include <stdarg.h>
#include <cstring>

#include "Graphs/Graph.hpp"
#include "Propagation_ImportPolicies/BGPDefaultImportPolicy.hpp"

//Temporary struct for building the ranks
struct RelationshipInfo {
    ASN asn;
    ASN_ID asnID;

    int rank;
    std::vector<ASN> peers, customers, providers, stubs;
};

/**
 * The plain C++ file buffering wasn't performing well in this case.
 * So here is a basic file buffer that lets you write into a buffer and flushes when it gets too full
 * The idea of the threshold is to assume no individual write will be bigger than 1000 bytes
 * (since we don't know the size of the string generated by sprintf before writing (easily))
 * If we go over the threshold, flush to the actual file.
 */
class FileBuffer {
private:
    static const int BUFFER_CAPACITY = 10000;
    static const int BUFFER_FLUSH_THRESHOLD = 1000;

    char buffer[BUFFER_CAPACITY];
    int bufferLength;

    FILE *f;

public:
    FileBuffer(FILE *f) : bufferLength(0), f(f) {

    }

    void write(const char *format, ...) {
        va_list argptr;
        va_start(argptr, format);
        //vfprintf(stderr, format, argptr);
        bufferLength += vsprintf(&buffer[bufferLength], format, argptr);

        if (bufferLength > BUFFER_CAPACITY - BUFFER_FLUSH_THRESHOLD) {
            fwrite(buffer, sizeof(char), bufferLength, f);
            bufferLength = 0;
        }

        va_end(argptr);
    }

    void flush() {
        fwrite(buffer, sizeof(char), bufferLength, f);
        bufferLength = 0;
    }
};

Graph::Graph(const std::string &relationshipsFilePath, std::unordered_map<ASN, std::vector<ASN>> customerToProviderPreferences, const bool stubRemoval) 
    : customerToProviderPreferences(customerToProviderPreferences), stubRemoval(stubRemoval)
{
    rapidcsv::Document relationshipsCSV(relationshipsFilePath, rapidcsv::LabelParams(0, -1), rapidcsv::SeparatorParams(SEPARATED_VALUES_DELIMETER));
    std::vector<RelationshipInfo> relationshipInfo;

    size_t maximumRank = 0;
    ASN_ID nextID = 0;

    //Store the relationships, assign IDs, and find the maximum rank
    for (size_t rowIndex = 0; rowIndex < relationshipsCSV.GetRowCount(); rowIndex++) {
        if (stubRemoval && relationshipsCSV.GetCell<std::string>("stub", rowIndex) == "TRUE")
            continue;

        RelationshipInfo info;

        info.asn = relationshipsCSV.GetCell<ASN>("asn", rowIndex);
        info.asnID = nextID;

        asnToID.insert({ info.asn, info.asnID });
        idToASN.push_back(info.asn);

        info.rank = relationshipsCSV.GetCell<int>("propagation_rank", rowIndex);

        if (info.rank > maximumRank)
            maximumRank = info.rank;

        info.providers = Util::parseASNList(relationshipsCSV.GetCell<std::string>("providers", rowIndex));
        info.peers = Util::parseASNList(relationshipsCSV.GetCell<std::string>("peers", rowIndex));
        info.customers = Util::parseASNList(relationshipsCSV.GetCell<std::string>("customers", rowIndex));
        info.stubs = Util::parseASNList(relationshipsCSV.GetCell<std::string>("stubs", rowIndex));

        // write down the priorities to be lookedup later during seeding
        //PERF_TODO: These can be optimized (redundant inserts). Eh? Is it worth it?
        for (auto providerASN : info.providers) {
            relationshipPriority.insert({ std::make_pair(info.asn, providerASN), RELATIONSHIP_PRIORITY_CUSTOMER_TO_PROVIDER });
            relationshipPriority.insert({ std::make_pair(providerASN, info.asn), RELATIONSHIP_PRIORITY_PROVIDER_TO_CUSTOMER });
        }

        for (auto peerASN : info.peers) {
            relationshipPriority.insert({ std::make_pair(info.asn, peerASN), RELATIONSHIP_PRIORITY_PEER_TO_PEER });
            relationshipPriority.insert({ std::make_pair(peerASN, info.asn), RELATIONSHIP_PRIORITY_PEER_TO_PEER });
        }

        for (auto cutomerASN : info.customers) {
            relationshipPriority.insert({ std::make_pair(info.asn, cutomerASN), RELATIONSHIP_PRIORITY_PROVIDER_TO_CUSTOMER });
            relationshipPriority.insert({ std::make_pair(cutomerASN, info.asn), RELATIONSHIP_PRIORITY_CUSTOMER_TO_PROVIDER });
        }

        relationshipInfo.push_back(info);

        idToImportPolicy.push_back(std::unique_ptr<BGPPolicy>(new BGPPolicy(info.asn, info.asnID)));

        nextID++;
    }

    //***** Memory Allocation ******/
    asIDToProviderIDs.resize(relationshipInfo.size());
    asIDToPeerIDs.resize(relationshipInfo.size());
    asIDToCustomerIDs.resize(relationshipInfo.size());
    idToASN.resize(relationshipInfo.size());

    // Only allocates a slot. Does not allocate entire local rib
    // Essentially giving the number of columns, but not filling in any rows
    localRibs.SetNumASes(relationshipInfo.size());
    
    //***** Relationship Parsing *****//

    // Allocate space for the rank structure and point its content to the corresponding data
    // Also put the pointer to other AS data in relationship structures 

    //ranks are 0 indexed, so the size of the structure holding the ranks is 1 + maximum index
    rankToIDs.resize(maximumRank + 1);
    for (int i = 0; i < relationshipInfo.size(); i++) {
        RelationshipInfo& info = relationshipInfo[i];

        rankToIDs[relationshipInfo[i].rank].push_back(info.asnID);

        // Write down the ASN and ID of each AS for each relationship
        for (ASN provider : info.providers) {
            auto idSearch = asnToID.find(provider);
            if (idSearch == asnToID.end())
                continue;

            asIDToProviderIDs[i].push_back( { provider, idSearch->second } );
        }

        for (ASN peer : info.peers) {
            auto idSearch = asnToID.find(peer);
            if (idSearch == asnToID.end())
                continue;

            asIDToPeerIDs[i].push_back( { peer, idSearch->second } );
        }

        for(ASN stubASN : info.stubs) {
            stubASNToProviderID.insert(std::make_pair(stubASN, i));
        }

        for (ASN customer : info.customers) {
            auto idSearch = asnToID.find(customer);
            if (idSearch == asnToID.end())
                continue;

            asIDToCustomerIDs[i].push_back( { customer, idSearch->second } );
        }
    }
}

void Graph::ResetAllAnnouncements() {
    for (int i = 0; i < GetNumASes(); i++) {
    for (int j = 0; j < GetNumPrefixes(); j++) {
        AnnouncementCachedData& ann = GetCachedData(i, j);
        ann.SetDefaultState();
    }}
}

void Graph::ResetAllNonSeededAnnouncements() {
    for (int i = 0; i < GetNumASes(); i++) {
    for (int j = 0; j < GetNumPrefixes(); j++) {
        AnnouncementCachedData& ann = GetCachedData(i, j);
        if (ann.isSeeded())
            continue;

        ann.SetDefaultState();
    }}
}

void Graph::SeedBlock(const std::string& filePathAnnouncements, const SeedingConfiguration &config) {
    rapidcsv::Document announcements_csv(filePathAnnouncements, rapidcsv::LabelParams(0, -1), rapidcsv::SeparatorParams(SEPARATED_VALUES_DELIMETER));

    // Allocate memory for the local ribs and the static announcement data
    announcementStaticData.resize(announcements_csv.GetRowCount());   
    localRibs.SetNumPrefixes(announcements_csv.GetRowCount()); // poor-man estimate of the number of unique prefixes

    ResetAllAnnouncements();

    for (size_t row_index = 0; row_index < announcements_csv.GetRowCount(); row_index++) {
        //***** PARSING
        std::string prefixString = announcements_csv.GetCell<std::string>("prefix", row_index);
        std::string as_path_string = announcements_csv.GetCell<std::string>("as_path", row_index);

        std::vector<ASN> as_path = Util::parseASNList(as_path_string);

        int64_t timestamp = announcements_csv.GetCell<int64_t>("timestamp", row_index);
        ASN origin = announcements_csv.GetCell<ASN>("origin", row_index);

        uint32_t prefix_id = announcements_csv.GetCell<uint32_t>("prefix_id", row_index);
        uint32_t prefix_block_id = announcements_csv.GetCell<uint32_t>("prefix_block_id", row_index);

        Prefix prefix;
        prefix.global_id = prefix_id;
        prefix.block_id = prefix_block_id;

        SeedPath(as_path, row_index, prefix, prefixString, timestamp, config);
    }
}

//TODO Recieved_from needs to be much more robust to the absence of known ASNs in the graph.
//TODO: Needs error detection and reporting.
void Graph::SeedPath(const std::vector<ASN>& asPath, size_t staticDataIndex, const Prefix& prefix, const std::string& prefixString, int64_t timestamp, const SeedingConfiguration &config) {
    if (asPath.size() == 0)
        return;

    AnnouncementStaticData &staticData = announcementStaticData[staticDataIndex];

    staticData.originASN = asPath[asPath.size() - 1];
    staticData.prefix = prefix;
    staticData.timestamp = timestamp;
    staticData.prefixString = prefixString;

    ASN_ID lastID;
    bool lastIDSet = false;

    int end_index = config.originOnly ? asPath.size() - 1 : 0;
    for (int i = asPath.size() - 1; i >= end_index; i--) {
        // If AS not in the graph, skip it
        // TODO: This should be an error
        auto asn_search = asnToID.find(asPath[i]);
        if (asn_search == asnToID.end()) {
            auto stubSearch = stubASNToProviderID.find(asPath[i]);
            if (stubRemoval && (config.originOnly || asPath.size() == 1) && stubSearch != stubASNToProviderID.end()) {
                // We have a stub on the path during stub removal, and it is the only one getting a seeded announcement.
                // When removing stubs, this is a problem because there is no local rib to put the announcement in (since the stub was removed).
                // Thus we must propagate to the provider now
                // TODO handle when there is more than one stub propagating the same prefix (technically the ann in the stub is seeded. This is not accounted for in the result generation)

                AnnouncementCachedData &providerAnn = localRibs.GetAnnouncement(stubSearch->second, prefix.block_id);
                if (providerAnn.isDefaultState()) {
                    providerAnn.SetRelationship(RELATIONSHIP_PRIORITY_CUSTOMER_TO_PROVIDER);
                    providerAnn.SetStaticDataIndex(staticDataIndex);
                    providerAnn.SetPathLength(2);
                    providerAnn.SetRecievedFromID(stubSearch->second);
                }
            }
            continue;
        }

        //If there is prepending, then just keep going along the path. The length is accounted for.
        if (i < asPath.size() - 1 && asPath[i] == asPath[i + 1])
            continue;

        ASN currentASN = asn_search->first;
        ASN_ID currentID = asn_search->second;

        uint8_t relationship = RELATIONSHIP_PRIORITY_ORIGIN;
        if (i < asPath.size() - 1) {
            auto search = relationshipPriority.find(std::make_pair(asPath[i + 1], currentASN));
            if (search == relationshipPriority.end()) {
                //TODO check for stub: https://github.com/c-morris/BGPExtrapolator/commit/364abb3d70d8e6aa752450e756348b2e1f82c739
                relationship = RELATIONSHIP_PRIORITY_BROKEN;
            } else {
                relationship = search->second;
            }
        }

        uint8_t newPathLength = asPath.size() - i;
        ASN_ID recievedFromID;
        if (lastIDSet)
            recievedFromID = lastID;
        else
            recievedFromID = currentID;

        lastIDSet = true;
        lastID = currentID;

        //TODO: Not all of these if-statements plz
         
        //If there exists an announcement for this prefix already
        AnnouncementCachedData& currentAnn = GetCachedData(currentID, prefix.block_id);

        //Recieve from itself if it is the origin
        ASN recieved_from_asn = i < asPath.size() - 1 ? asPath[i + 1] : currentASN;

        if (!currentAnn.isDefaultState()) {
            const AnnouncementStaticData &currentStaticData = announcementStaticData[currentAnn.GetStaticDataIndex()];
            int64_t currentTimestamp = currentStaticData.timestamp;
            ASN currentRecievedFromASN;

            if (stubRemoval && (currentAnn.GetRecievedFromID() == currentID && currentAnn.GetPathLength() == 2)) {
                // if this is a provider to a stub, the ann will point back to the provider
                // but that is not the correct ASN. Get the stub's ASN instead
                currentRecievedFromASN = currentStaticData.originASN;
            } else {
                currentRecievedFromASN = idToASN[currentAnn.GetRecievedFromID()];
            }

            if (config.timestampComparison == TIMESTAMP_COMPARISON::PREFER_NEWER && timestamp > currentTimestamp)
                continue;
            else if (config.timestampComparison == TIMESTAMP_COMPARISON::PREFER_OLDER && timestamp < currentTimestamp)
                continue;

            if (timestamp == currentTimestamp) {
                uint8_t currentRelationship = currentAnn.GetRelationship();
                uint8_t currentPathLength = currentAnn.GetPathLength();
                if (currentRelationship > relationship || currentPathLength < newPathLength)
                    continue;

                if (currentRelationship == relationship && currentPathLength == newPathLength) {
                    if (config.tiebrakingMethod == TIEBRAKING_METHOD::RANDOM) {
                        if (rand() % 2 == 0)
                            continue;
                    } else {//lowest recieved_from ASN wins
                        if (currentRecievedFromASN < recieved_from_asn)
                            continue;
                    }
                }
            }
        }

        //accept the announcement
        currentAnn.SetPathLength(newPathLength);
        currentAnn.SetRecievedFromID(recievedFromID);
        currentAnn.SetRelationship(relationship);
        currentAnn.SetSeeded(true);
        currentAnn.SetStaticDataIndex(staticDataIndex);
    }
}

void Graph::Propagate() {
    // ************ Propagate Up ************//

    // start at the second rank because the first has no customers
    for (size_t i = 1; i < rankToIDs.size(); i++) {
        for (auto& providerID : rankToIDs[i]) {
            for (auto& customerID : asIDToCustomerIDs[providerID]) {

                idToImportPolicy[providerID]->ProcessCustomerAnnouncements(*this, customerID);
            }
        }
    }

    for (size_t i = 0; i < rankToIDs.size(); i++) {
        for (auto& asID : rankToIDs[i]) {
            for (auto& peerID : asIDToPeerIDs[asID]) {
                idToImportPolicy[asID]->ProcessPeerAnnouncements(*this, peerID);
             }
        }
    }


    // ************ Propagate Down ************//
    //Customer looks up to the provider and looks at its data, that is why the - 2 is there
    for (int i = rankToIDs.size() - 2; i >= 0; i--) {
        for (auto& customerID : rankToIDs[i]) {
            for (auto& providerID : asIDToProviderIDs[customerID]) {
                idToImportPolicy[customerID]->ProcessProviderAnnouncements(*this, providerID);
            }
        }
    }
}

void Graph::Traceback(std::vector<ASN> &as_path, const ASN startingASN, const uint32_t prefixBlockID) const {
    as_path.clear();

    auto starting_search = asnToID.find(startingASN);
    if (starting_search == asnToID.end())
        return;

    ASN_ID asnID = starting_search->second;
    size_t path_length = 1;
    as_path.push_back(startingASN);

    // If the path length is greater than 99, there is a cycle or soem other kind of problem. Path lengths should not be this long
    while (path_length < 99) {
        const AnnouncementCachedData& ann = GetCachedData_ReadOnly(asnID, prefixBlockID);

        // origin recieves from itself
        if (ann.GetRecievedFromID() == asnID) {
            if (ann.GetPathLength() == 2) {
                // this means that the origin was not in the graph (stub removal)
                // but we can get the ASN from the static info since it the origin
                as_path.push_back(GetStaticData_ReadOnly(ann.GetStaticDataIndex()).originASN);
                path_length++;
            }
            break;
        }

        asnID = ann.GetRecievedFromID();
        as_path.push_back(idToASN[asnID]);
        path_length++;
    }
}

// ************************ FILE I/O ************************ //
 
//TODO: Check the provider local rib after seeding for stub removal. See if the stub's ASN is the recieved_from_asn when the stub is the origin. Add a check for this when generating the localribs
void Graph::GenerateTracebackResultsCSV(const std::string& resultsFilePath, std::vector<ASN> localRibsToDump) {
    //Create the file, delete if it exists already (std::fstream::trunc)
    FILE *f = fopen(resultsFilePath.c_str(), "w");
    FileBuffer fileBuffer(f);

    if (localRibsToDump.empty()) {
        for (const auto& kv : asnToID)
            localRibsToDump.push_back(kv.first);
        if (stubRemoval) {
            for (const auto& kv : stubASNToProviderID)
                localRibsToDump.push_back(kv.first);
        }
    }

    //First, dump the static info at the top of the file
    fileBuffer.write("prefix\torigin\ttimestamp\tas_path\n");
    
    //Only dump the RIB of ASes we care about.
    std::vector<ASN> as_path;
    for (auto asn : localRibsToDump) {
        // Determine the ID and ASN of the current AS.
        // Gets funky if we are interested in a stub, where we trace from the provider and then append to the path
        ASN_ID id;
        int64_t stubASN = -1;

        auto id_search = asnToID.find(asn);
        if (id_search == asnToID.end()) {
            auto stub_search = stubASNToProviderID.find(asn);
            if (stub_search == stubASNToProviderID.end())
                continue;

            id = stub_search->second;
            asn = idToASN.at(id);
            stubASN = stub_search->first;
        } else {
            id = id_search->second;
        }

        for (uint32_t prefixBlockID = 0; prefixBlockID < GetNumPrefixes(); prefixBlockID++) {
            const AnnouncementCachedData &ann = GetCachedData(id, prefixBlockID);
            
            //Do nothing if there is no actual announcement at the prefix
            if (ann.isDefaultState())
                continue;

            as_path.clear();
            Traceback(as_path, asn, prefixBlockID);

            //***** Build String
            AnnouncementStaticData& staticData = announcementStaticData[ann.GetStaticDataIndex()];

            fileBuffer.write("%s\t%i\t%lli\t{", staticData.prefixString.c_str(), staticData.originASN, staticData.timestamp);

            if (stubASN >= 0) {
                // If the AS path has the stub as the origin and we are dumping the local rib of the stub
                // Then the path will have the provider and the stub, which is not correct
                if (as_path[as_path.size() - 1] == stubASN) {
                    fileBuffer.write("%d", stubASN);
                    as_path.clear();
                } else {
                    fileBuffer.write("%d,", stubASN);
                }
            }

            for (size_t j = 0; j < as_path.size(); j++) {
                if (j == as_path.size() - 1)
                    fileBuffer.write("%d", as_path[j]);
                else
                    fileBuffer.write("%d,", as_path[j]);
            }
            
            fileBuffer.write("}\n");
        }
    }

    fileBuffer.flush();
    fclose(f);
}
